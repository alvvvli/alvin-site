<script>
(function(){
  const AUTO_START = true; // set true if you want auto-run inside iframes
  // Drop forgiveness (tune as you like)
  const DROP_BUFFER_X_PCT = 0.35; // accept if center-X is within platform column ± 35% of train width
  const DROP_BUFFER_Y = 36;       // extra px above/below the dashed zone that count as a valid drop

  const lanesEl = document.getElementById('lanes');
  const board   = document.getElementById('board');
  const toast   = document.getElementById('toast');
  const scoreEl = document.getElementById('score');
  const timeEl  = document.getElementById('time');
  const comboEl = document.getElementById('combo');
  const playBtn = document.getElementById('playBtn');
  const howBtn  = document.getElementById('howBtn');
  const howDialog   = document.getElementById('howDialog');
  const closeHow    = document.getElementById('closeHow');
  const startFromHow= document.getElementById('startFromHow');

  const PLATFORM_COUNT = 5;
  const SPAWN_MS_MIN = 1100, SPAWN_MS_MAX = 1900;
  const TRAIN_SPEED = 0.18; // px per ms

  let running=false, score=0, timeLeft=60, combo=1, tickTimer=null, spawnTimer=null;
  const trains = new Set();

  function initBoard(){
    lanesEl.innerHTML='';
    for(let i=1;i<=PLATFORM_COUNT;i++){
      const p=document.createElement('div'); p.className='platform'; p.dataset.id=i;
      const lab=document.createElement('div'); lab.className='label'; lab.textContent='Platform '+i;
      const t=document.createElement('div'); t.className='target'; t.textContent='Drop Here'; t.dataset.id=i;
      p.append(lab,t); lanesEl.appendChild(p);
    }
  }

  const THEMES=['theme-blue','theme-green','theme-yellow','theme-purple','theme-red'];
  const MODELS = [
    {code:'E5', livery:'livery-e5'},
    {code:'H5', livery:'livery-h5'},
    {code:'E6', livery:'livery-e6'},
    {code:'E7', livery:'livery-e7'},
    {code:'W7', livery:'livery-e7'},
    {code:'N700S', livery:'livery-n700s'},
    {code:'800', livery:'livery-800'}
  ];

  const rand=a=>a[Math.floor(Math.random()*a.length)];
  const between=(a,b)=>a+Math.random()*(b-a);
  const rect = el => el.getBoundingClientRect();
  function vibrate(ms){ if(navigator.vibrate) try{ navigator.vibrate(ms); }catch(e){} }

  function showToast(msg, type){
    toast.textContent=msg; toast.classList.remove('good','bad');
    if(type) toast.classList.add(type);
    toast.classList.add('show');
    setTimeout(()=>toast.classList.remove('show'), 850);
  }

  function startGame(){
    if(running) return;
    running=true; score=0; timeLeft=60; combo=1;
    trains.forEach(killTrain); trains.clear();
    scoreEl.textContent=score; timeEl.textContent=timeLeft; comboEl.textContent='x'+combo;

    tickTimer = setInterval(()=>{
      timeLeft--; timeEl.textContent=timeLeft; 
      if(timeLeft<=0) endGame();
    }, 1000);

    spawnTrain();
    scheduleSpawn();
    showToast('Dispatch started — good luck!', 'good');
  }

  function endGame(){
    running=false; clearInterval(tickTimer); clearTimeout(spawnTimer);
    trains.forEach(killTrain); trains.clear();
    const rank = score>=3500 ? 'JR East Pro' : score>=2500 ? 'Station Master' : score>=1500 ? 'Dispatcher' : 'Conductor';
    showToast(`Time! Score ${score} — Rank: ${rank}`, 'good');
    playBtn.textContent='Play Again';
  }

  function scheduleSpawn(){
    if(!running) return;
    spawnTimer = setTimeout(()=>{ spawnTrain(); scheduleSpawn(); }, between(SPAWN_MS_MIN, SPAWN_MS_MAX));
  }

function spawnTrain(){
  // Wait until the board has a real size (common inside iframes)
  if (!board.clientWidth || !board.clientHeight){
    requestAnimationFrame(spawnTrain); // try on the next frame
    return;
  }

  const platform = Math.ceil(Math.random()*PLATFORM_COUNT);
  const theme = rand(THEMES);
  const model = rand(MODELS);

  const usable = Math.max(200, board.clientHeight - 210);
  const y = 96 + Math.floor(Math.random() * usable);

  const el = document.createElement('div');
  el.className = `train ${theme} ${model.livery}`;
  el.style.top  = y + 'px';

  // Start slightly inside the board so it's visible *immediately*
  const startX = Math.max(10, board.clientWidth - 140); // 140 ≈ train width minus nose
  el.style.left = startX + 'px';

  el.dataset.target = String(platform);
  el.dataset.vx     = String(-between(0.12, TRAIN_SPEED));
  el.dataset.model  = model.code;

  el.innerHTML = `<span class="badge">P${platform}</span>
                  <span class="nose"></span>
                  <div class="cars">${'<div class="car"></div>'.repeat(5 + Math.floor(Math.random()*4))}</div>`;

  board.appendChild(el);
  const obj = {el, grabbed:false, x: startX, y, vx: parseFloat(el.dataset.vx)};
  trains.add(obj);

  // debug
  console.log('spawn', {platform, model: model.code, x: obj.x, y: obj.y, vx: obj.vx});

  el.addEventListener('pointerdown', e=>{
    obj.grabbed=true; el.setPointerCapture(e.pointerId);
    obj.offsetX = e.clientX - obj.x; obj.offsetY = e.clientY - obj.y;
  });
  el.addEventListener('pointermove', e=>{
    if(!obj.grabbed) return;
    obj.x = e.clientX - obj.offsetX; obj.y = e.clientY - obj.offsetY;
    updateTrain(obj);
  });
  el.addEventListener('pointerup', ()=>{ obj.grabbed=false; checkDrop(obj); });
}

  function killTrain(t){ if(!t || !t.el) return; t.el.remove(); }
  function updateTrain(t){ if(!t.el) return; t.el.style.left = t.x+'px'; t.el.style.top = t.y+'px'; }

  // ---------- FIX: game loop must be top-level, not inside checkDrop ----------
  let last = performance.now();
  function gameLoop(now){
    const dt = now - last; last = now;
    if(running){
      trains.forEach(t=>{
        if(!t.grabbed){ t.x += t.vx * dt; updateTrain(t); }
        if(t.x < -300){
          showToast('Missed dispatch — minor delay announced.', 'bad');
          combo=1; comboEl.textContent='x'+combo;
          t.el.remove(); trains.delete(t);
        }
      });
    }
    requestAnimationFrame(gameLoop);
  }
  
  function checkDrop(t){
    const me = rect(t.el);
    const cx = (me.left + me.right) / 2;
    const trainW = me.width;
    const plats = [...document.querySelectorAll('.platform')];

    let hitPlat = null, chosenTarget = null, chosenRect = null;
    for (const p of plats){
      const pr = rect(p);
      const bufferX = Math.max(24, trainW * DROP_BUFFER_X_PCT);
      const left = pr.left - bufferX, right = pr.right + bufferX;
      if (cx >= left && cx <= right){
        hitPlat = p; chosenTarget = p.querySelector('.target'); chosenRect = rect(chosenTarget); break;
      }
    }
    if (!hitPlat) return;

    const expandedTop = chosenRect.top - DROP_BUFFER_Y;
    const expandedBottom = chosenRect.bottom + DROP_BUFFER_Y;
    const vertOk = !(me.bottom < expandedTop || me.top > expandedBottom);
    if (!vertOk) return;

    const ok = String(hitPlat.dataset.id) === String(t.el.dataset.target);
    if (ok){
      const center = (chosenRect.left + chosenRect.right) / 2;
      const dx = Math.abs(cx - center);
      let add = 60; if (dx < 36) add = 100; else if (dx < 90) add = 80;
      score += Math.round(add * combo);
      combo = Math.min(10, combo + 0.25);
      scoreEl.textContent = score;
      comboEl.textContent = 'x' + combo.toFixed(2).replace(/\.00$/,'');
      vibrate(12); showToast('On-time dispatch ✓', 'good');
    } else {
      score = Math.max(0, score - 75);
      combo = 1;
      scoreEl.textContent = score;
      comboEl.textContent = 'x' + combo;
      vibrate(30); showToast('Wrong platform — delay!', 'bad');
    }
    t.el.remove(); trains.delete(t);
  }

  // UI wiring
  playBtn.addEventListener('click', startGame);
  howBtn.addEventListener('click', ()=>howDialog.showModal());
  closeHow.addEventListener('click', ()=>howDialog.close());
  startFromHow.addEventListener('click', ()=>{ howDialog.close(); startGame(); });
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden && running) endGame(); });

  // boot
  initBoard();
  requestAnimationFrame(gameLoop);   // <- runs the loop
  if (AUTO_START) startGame();
})();
</script>
